---
title: 初识协议UI
description: 为什么我们使用“radix-ui”，“Shadcn/UI”，“Tailwind CSS”以及“assistant-ui”这些技术栈
---

## Headless UI 是定制化的基石
是因为它将 UI 的逻辑（状态、行为、交互） 与 视觉表现（样式、结构） 彻底分离，让开发者能够完全自由地定制外观，同时复用一套经过严格测试的核心交互逻辑。

### 什么是无头组件
无头组件是指 只提供功能逻辑、不提供任何预设样式和 DOM 结构 的 UI 组件库。

你得到的是组件的行为管理（如打开/关闭、选择、键盘导航、焦点管理等），而视觉部分完全由你自己实现。

### 为什么使用无头组件
1. 彻底分离逻辑与视觉
传统 UI 组件库（如 Material-UI、Ant Design）将逻辑、样式和 DOM 结构捆绑在一起。

    而无头组件只负责：
     - 状态管理（如 open、selected）
     - 交互逻辑（键盘导航、焦点陷阱、点击外部关闭）
     - 无障碍（ARIA 属性）
     - 事件处理

视觉部分（颜色、间距、动画、DOM 结构）100% 由开发者控制。

2. 无样式约束
传统组件库通常很难深度定制样式，无论是你使用何种技术方案，如 CSS-in-JS、CSS Modules、Sass 等，你都避免不了样式覆盖的问题。

3. 结构可任意重组
无头组件的 DOM 结构完全由你控制，你可以将组件组合成任何结构，你可以根据你自己的需求来定义组件的布局和样式。

### 使用痛点

1. 起步成本高
     - 从零搭建视觉层：每个组件都需要自己实现完整的样式和 DOM 结构
     - 决策疲劳：需要决定按钮、弹窗、菜单等每个细节的样式和行为
     - 初期投入大：在项目初期，开发速度远低于使用全功能组件库
2. 设计一致性维护困难
     - 组件间不一致：不同开发者实现的相同组件可能风格各异
     - 设计系统执行依赖自觉：需要严格的代码评审和设计规范文档
     - 重构成本高：如果要修改设计规范，需要修改每个组件的实现
3. 状态管理复杂度外露
     - 需要深入理解组件的完整状态机
     - 错误处理、边界情况都需要自己考虑
4. 测试负担加重
     - 交互逻辑和视觉表现都需要测试
     - 需要编写大量测试用例覆盖各种交互状态
     - 视觉回归测试变得更加重要
5. 学习曲线陡峭
     - 无头组件的 API 很精简，需要学习新的 API
     - 公司内部的设计系统
     - 自定义的组件实现模式
6. 知识分散
     - 组件逻辑分散在多个地方：Headless 库 + 自定义实现 + 设计系统
     - 调试困难：问题可能出现在任何一层
     - 文档维护成本高：需要为自定义组件编写完整文档
7. 版本升级风险
     - Headless 库的 API 变更会影响所有组件
     - 需要全量回归测试
     - 自定义实现可能依赖特定版本的行为
8. 性能优化负担
     - 虚拟滚动、懒加载等性能优化都需要自己实现
     - 需要监控和优化自定义组件的渲染性能
     - 打包优化需要额外配置

## 核心矛盾

1. 必须要有设计系统
2. 对定制化有极高要求
3. 这是一项长期维护投资

### Shadcn/UI，Tailwind CSS齐上阵
Shadcn/UI 是一个基于 Tailwind CSS 的 无头组件库。基于Shadcn/UI与Tailwind CSS的结合，可以快速实现一个无头组件库，并且很好的与设计系统对接。

同时基于Shadcn的分发方式，使用者可以在本地直接修改实现逻辑，随意定制其需求。

### Assistant-UI 也遵循这个思路
Assistant-UI也是基于Shadcn/UI与Tailwind CSS，提供了一套完整的无头组件库，并且可以很好的与设计系统对接。

同时它还提供了大量的AI Chat组件，可以帮助用户快速实现一个完整的聊天界面。

## 共性

我们之所以选择这些技术栈，是因为它们本质上都是协议UI。它可以很好的与设计系统对接，天然的适配SRC，低代码开发，且是AI友好的。

### 挑战与机遇并存

基于协议UI开发的挑战是巨大的，首先就是开发思维的转变。

有些实现你看起来很奇怪，但是它符合协议UI的逻辑。

比如：`<XXX.If condition>{children}</XXX.If>`这种条件渲染组件，明明使用`condition && children`更加简洁明了。

或者：`<XXXPrimitive asChild>{child}</XXXPrimitive>`你会觉得这很奇怪，为什么不用插槽？

再或则：`<XXX.Root>{children}</XXX.Root>`以及`<XXX.Trigger></XXX.Trigger>`它们到底是什么关系？干啥的？为什么要这样包一层？

其实它们只是为了符合协议UI的做法，协议优先原则，这些写法在“人类”看起来很奇怪，但是它们是更符合协议表达的。

你仔细观察，Tailwind / Radix / shadcn它们其实更像是**DSL**，因为他们本身就是基于协议而设计的，而我们如果基于协议UI的方式开发，思维方式的转变是必要的。

### AI友好是第一性
协议UI的技术栈，天然的就是AI友好的。它们的代码更容易被AI训练与生成，而我们如果都基于协议UI来编写代码，那么这些代码更容易的被AI使用。

所以AI友好是第一性，我们不只是开发一个无头组件库，或者一个AI应用，而是写AI友好代码。
