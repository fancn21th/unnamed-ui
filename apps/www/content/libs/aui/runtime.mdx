---
title: å¦‚ä½•è‡ªå®šä¹‰Runtime
description: ä½¿ç”¨è‡ªå®šä¹‰Runtimeå®šåˆ¶ä½ è‡ªå·±çš„ä¸šåŠ¡
---

## AUIä¸­çš„Runtimeè®¾è®¡
ç”±äºAUIæ˜¯ä¸€ä¸ªæ— å¤´ç»„ä»¶æ¡†æ¶ï¼Œå®ƒæä¾›äº†å¤§é‡çš„Primitiveç»„ä»¶ï¼Œä½†æ˜¯å¯¹äºæŸäº›ä¸šåŠ¡åœºæ™¯ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå®šä¹‰ä¸€äº›ä¸šåŠ¡ï¼Œè¿™æ—¶å°±éœ€è¦ä½¿ç”¨runtimeã€‚

AUIä¸­æä¾›äº†è‡ªå®šä¹‰Runtimeçš„hooksï¼Œè®©ä½ å¯ä»¥è‡ªå®šä¹‰ä¸€äº›ä¸šåŠ¡é€»è¾‘ã€‚è€Œruntimeä¸­å¯ä»¥å®ç°ä¸€äº›Adapterï¼Œè®©AUIä¸­çš„ç»„ä»¶å’Œruntimeä¸­çš„ä¸šåŠ¡é€»è¾‘è¿›è¡Œäº¤äº’ã€‚

å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒAUIä¸­ä½¿ç”¨äº†`runtimeHook`çš„è®¾è®¡ï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¿…é¡»è¿”å›ä¸€ä¸ªæ–°çš„Runtimeã€‚

## è‡ªå®šä¹‰ä¼šè¯å†å²è®°å½•
å®šä¸€ä¸ªæœ€åŸºæœ¬çš„Runtimeï¼ŒruntimeHookä¸­å®ç°ä½ Chatç›¸å…³çš„Runtimeï¼Œadapterå®ç°ä½ è‡ªå®šä¹‰çš„ä¼šè¯å†å²è®°å½•é€»è¾‘ã€‚

```ts
// åˆ›å»ºç¬¦åˆ assistant-ui æ ‡å‡†çš„è¿è¡Œæ—¶
export const useSmartVisionChatRuntime = () => {
  /**
   * å®ç°è‡ªå®šä¹‰ä¼šè¯å†å²è®°å½•ï¼Œå…³é”®æ˜¯è¦å®ç°è¿™ä¸ªAdapter
   * */
  const threadListAdapter = useSmartVisionThreadListAdapter();

  return useRemoteThreadListRuntime({
    /**
     * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ æ³¨æ„
     * è¿™é‡Œå¿…é¡»è¿”å›ä¸€ä¸ªæ–°çš„ChatThreadRuntimeå®ä¾‹
     * å¦åˆ™ä¼šå¯¼è‡´çº¿ç¨‹åˆ—è¡¨å’ŒèŠå¤©çº¿ç¨‹ä¹‹é—´çš„çŠ¶æ€æ··ä¹±
     * è§£é‡Šï¼šassistant-ui æ¯ä¸€ä¸ªèŠå¤©ä¼šè¯å¯¹åº”ä¸€ä¸ªèŠå¤©çš„runtime
     * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
     * */
    runtimeHook: () => useSmartVisionChatThreadRuntime(),
    adapter: threadListAdapter,
  });
};
```

### å®ç°è‡ªå®šä¹‰ä¼šè¯å†å²è®°å½•Adapter
é€šè¿‡è¿™ä¸ªAdapterè·Ÿä½ ä½ çš„åç«¯è¿›è¡Œäº¤äº’ã€‚

```tsx
const useSmartVisionThreadListAdapter = (): RemoteThreadListAdapter => {
  const { initializeLink, generateTitleLink } =
    useSmartVisionThreadListAdapterLink();
  /**
   * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ æ³¨æ„
   * ä¸€å®šè¦å®ç°è¿™ä¸ªProviderç»„ä»¶
   * å¦åˆ™æ— æ³•æ­£ç¡®æ³¨å…¥è‡ªå®šä¹‰çš„å†å²è®°å½•å’Œé™„ä»¶é€‚é…å™¨
   * è¿™ä¸ªAdapterçš„æ ¸å¿ƒå…³é”®å°±æ˜¯è¦å®ç°è¿™ä¸ªProviderï¼Œå…¶å®ƒçš„æ–¹æ³•éƒ½æ˜¯è°ƒç”¨åç«¯API
   * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
   * */
  const unstable_Provider = useCallback<FC<PropsWithChildren>>(
    function Provider({ children }) {
      /**
       * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ æ³¨æ„
       * è¿™é‡Œçš„ThreadHistoryæŒ‡çš„æ˜¯ä¸€ä¸ªä¼šè¯çš„å†å²æ¶ˆæ¯ï¼Œå®ƒä¸æ˜¯ä¼šè¯åˆ—è¡¨
       * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
       * */
      const history = useSmartVisionThreadHistoryAdapter();
      /**
       * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ æ³¨æ„
       * è¿™é‡Œçš„é™„ä»¶Adapterä¸èµ·ä½œç”¨ï¼Œå› ä¸ºè¿™é‡Œè¿˜æ²¡æœ‰è¿ç§»åˆ°æœ€æ–°çš„å®ç°
       * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
       * */
      const attachments = useMemo(() => smartVisionFileAttachmentAdapter, []);
      const adapters = useMemo(
        () => ({
          history,
          attachments,
        }),
        [history, attachments],
      );

      return (
        <RuntimeAdapterProvider adapters={adapters}>
          {children}
        </RuntimeAdapterProvider>
      );
    },
    [],
  );
  return {
    async list() {
      const threads = await getConversationsList();
      return {
        threads: threads.map((d) => ({
          status: "regular",
          remoteId: d.id,
          title: d.name,
        })),
      };
    },
    async initialize(localId) {
      const remoteId = await initializeLink(localId);
      return { remoteId, externalId: localId };
    },
    async rename(remoteId, title) {
      await fetch(`/api/threads/${remoteId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title }),
      });
    },
    async archive(remoteId) {
      await fetch(`/api/threads/${remoteId}/archive`, { method: "POST" });
    },
    async unarchive(remoteId) {
      await fetch(`/api/threads/${remoteId}/unarchive`, { method: "POST" });
    },
    async delete(remoteId) {
      await fetch(`/api/threads/${remoteId}`, { method: "DELETE" });
    },
    async fetch(remoteId) {
      const response = await fetch(`/api/threads/${remoteId}`);
      const thread = await response.json();
      return {
        status: thread.is_archived ? "archived" : "regular",
        remoteId: thread.id,
        title: thread.title,
      };
    },
    async generateTitle(remoteId, messages) {
      return createAssistantStream(async (controller) => {
        const title = await generateTitleLink(remoteId);
        controller.appendText(title);
      });
    },
    unstable_Provider,
  };
};
```
## è‡ªå®šä¹‰å¯¹è¯
åˆ›å»ºä¸€å¯¹è¯çš„Runtimeï¼Œé€šè¿‡è¿™ä¸ªRuntimeï¼Œä½ å¯ä»¥å®ç°è‡ªå®šä¹‰çš„å¯¹è¯é€»è¾‘ã€‚ä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•è‡ªå®šä¹‰å‘é€æ–°æ¶ˆæ¯ï¼Œä»¥åŠæ¶ˆæ¯æ¨¡å‹è½¬æ¢ã€‚
```tsx
const useSmartVisionChatThreadRuntime = () => {
  const [isRunning, setIsRunning] = useState(false);
  const { messages, sendMessage, setMessages } = useSmartVisionMessages();

  const handleSendMessage = async (newMessages: SmartVisionMessage[]) => {
    try {
      setIsRunning(true);
      await sendMessage(newMessages);
    } catch (error) {
      console.error("Error streaming messages:", error);
    } finally {
      setIsRunning(false);
    }
  };

  // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä¸º assistant-ui æ ‡å‡†æ ¼å¼
  const threadMessages = useExternalMessageConverter({
    callback: convertSmartVisionMessages,
    messages,
    isRunning,
  });

  const contextAdapters = useRuntimeAdapters();
  const isLoading = useSmartVisionExternalHistory(
    contextAdapters?.history,
    getSmartVisionMessage,
    setMessages,
  );
  const runtime = useExternalStoreRuntime({
    isRunning,
    messages: threadMessages,
    setMessages: (messages) =>
      setMessages(messages.map(getSmartVisionMessage).filter(Boolean).flat()),
    onNew: async (message) => {
      console.log("ğŸš€ SmartVision onNew:", message);

      // åˆ›å»ºç”¨æˆ·æ¶ˆæ¯
      const userMessage: SmartVisionMessage = {
        id: `user_${Date.now()}`,
        type: "human",
        content: message.content.map((c) => {
          if (c.type === "text")
            return { type: "text", text: c.text } as SmartVisionContentPart;
          return { type: "text", text: "" } as SmartVisionContentPart;
        }),
        attachments: message.attachments,
      };
      await handleSendMessage([userMessage]);
    },
    onImport: (messages) =>
      setMessages(messages.map(getSmartVisionMessage).filter(Boolean).flat()),
    onEdit: async () => {},
    isLoading,
    adapters: {
      /**
       * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ æ³¨æ„
       * é™„ä»¶Adapterä¾ç„¶ä½¿ç”¨è€çš„æ–¹å¼å®ç°
       * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
       * */
      attachments: smartVisionFileAttachmentAdapter,
    },
  });
  return runtime;
};
```
### åŠ è½½å¯¹è¯å†å²æ¶ˆæ¯
è‡ªå®šä¹‰ä¸€ä¸ªå†å²æ¶ˆæ¯æ‰©å±•ï¼Œåœ¨åˆ›å»ºRuntimeæ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ‰©å±•æ¥åŠ è½½å†å²æ¶ˆæ¯ã€‚
```tsx
const useSmartVisionExternalHistory = <TMessage>(
  historyAdapter: ThreadHistoryAdapter | undefined,
  toStoreMessage: (messages: ThreadMessage) => TMessage,
  onSetMessages: (messages: TMessage[]) => void,
) => {
  const loadedRef = useRef(false);

  const api = useAssistantApi();
  const optionalThreadListItem = useCallback(
    () => (api.threadListItem.source ? api.threadListItem() : null),
    [api],
  );

  const [isLoading, setIsLoading] = useState(
    // we only load history if there is a remote id
    () => optionalThreadListItem()?.getState().remoteId !== undefined,
  );

  const historyIds = useRef(new Set<string>());

  const onSetMessagesRef = useRef<typeof onSetMessages>(() => onSetMessages);
  useEffect(() => {
    onSetMessagesRef.current = onSetMessages;
  });

  // Load messages from history adapter on mount
  useEffect(() => {
    if (!historyAdapter || loadedRef.current) return;

    const loadHistory = async () => {
      setIsLoading(true);
      try {
        const repo = await historyAdapter.load();
        if (repo && repo.messages.length > 0) {
          onSetMessagesRef.current(
            repo.messages
              .map((d) => toStoreMessage(d.message))
              .filter(Boolean)
              .flat() as TMessage[],
          );

          historyIds.current = new Set(repo.messages.map((m) => m.message.id));
        }
      } catch (error) {
        console.error("Failed to load message history:", error);
      } finally {
        setIsLoading(false);
      }
    };

    if (!loadedRef.current) {
      loadedRef.current = true;
      if (!optionalThreadListItem()?.getState().remoteId) {
        setIsLoading(false);
        return;
      }

      loadHistory();
    }
  }, [api, historyAdapter, optionalThreadListItem]);

  return isLoading;
};
```

å®ç°ä¸€ä¸ªè‡ªå®šä¹‰çš„å†å²Adapterï¼Œè¿™ä¸ªAdapterå¯¹æ¥ç«¯APIè¿›è¡Œæ•°æ®äº¤äº’åŠæ•°æ®è½¬æ¢ã€‚
```tsx
class SmartVisionThreadHistoryAdapter implements ThreadHistoryAdapter {
  constructor(private store: AssistantApi) {}

  /**
   * åŠ è½½ä¼šè¯çš„å†å²æ¶ˆæ¯
   * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸ æ³¨æ„
   * è¿™é‡Œçš„å®ç°æ˜¯è°ƒç”¨åç«¯APIè·å–å†å²æ¶ˆæ¯
   * ç„¶åå°†åç«¯è¿”å›çš„æ¶ˆæ¯æ ¼å¼è½¬æ¢ä¸º Assistant UI éœ€è¦çš„æ¶ˆæ¯æ ¼å¼
   * âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸âš ï¸
   * */
  async load() {
    const remoteId = this.store.threadListItem().getState().remoteId;
    if (!remoteId) return { messages: [] };
    const data = await getConversationsMessages(remoteId);
    const messages: { message: ThreadMessage; parentId: string | null }[] = [];
    data.forEach((d) => {
      const nanoId = nanoid();
      messages.push({
        message: {
          id: nanoId,
          createdAt: moment.unix(d.created_at).toDate(),
          role: "user",
          content: [
            {
              type: "text",
              text: d.query,
            },
          ],
          attachments: [],
          metadata: { custom: {} },
        } as ThreadUserMessage,
        parentId: null,
      });
      messages.push({
        message: {
          id: d.id,
          createdAt: moment.unix(d.created_at).toDate(),
          role: "assistant",
          status: { type: "complete", reason: "unknown" },
          content: [
            {
              type: "text",
              text: d.answer,
            },
          ],
          attachments: [],
          metadata: {
            unstable_state: null,
            unstable_annotations: [],
            unstable_data: [],
            steps: [],
            custom: {},
          },
        } as ThreadAssistantMessage,
        parentId: null,
      });
    });
    return {
      messages,
    };
  }
  async append() {}
}
const useSmartVisionThreadHistoryAdapter = () => {
  const store = useAssistantApi();

  return useMemo(() => new SmartVisionThreadHistoryAdapter(store), [store]);
};
```

### ä¸Šä¼ é™„ä»¶
åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„é™„ä»¶ä¸Šä¼ çš„Adapterï¼Œè¿™ä¸ªAdapterå¯¹æ¥ç«¯APIè¿›è¡Œæ•°æ®äº¤äº’åŠæ•°æ®è½¬æ¢ã€‚
```tsx
export const smartVisionFileAttachmentAdapter: AttachmentAdapter = {
  accept: "*/*",
  async *add({ file }: { file: File }): AsyncGenerator<PendingAttachment> {
    const id = nanoid();
    const queue = new AsyncQueue<UploadEvent>();
    yield {
      id,
      type: file.type.startsWith("image/") ? "image" : "file",
      name: file.name,
      file,
      contentType: file.type,
      status: {
        type: "running",
        progress: 0,
        reason: "uploading",
      },
    };
    uploadChatFile(file, (progress) => {
      queue.push({ type: "progress", value: progress });
    })
      .then((data) => {
        queue.push({ type: "complete", value: data });
      })
      .catch((error) => {
        queue.push({ type: "error", value: error });
        throw error;
      });
    // ä»é˜Ÿåˆ—ä¸­yieldäº‹ä»¶
    while (true) {
      const event = await queue.next();
      if (event.type === "error") {
        break;
      }
      if (event.type === "complete") {
        fileIdMap[id] = event.value.id;
        yield {
          id,
          type: file.type.startsWith("image/") ? "image" : "file",
          name: file.name,
          file,
          contentType: file.type,
          status: { type: "requires-action", reason: "composer-send" },
        };
        break;
      }
      yield {
        id,
        type: file.type.startsWith("image/") ? "image" : "file",
        name: file.name,
        file,
        contentType: file.type,
        status: {
          type: "running",
          progress: event.value,
          reason: "uploading",
        },
      };
    }
  },
  async remove(attachment: Attachment) {
    // noop
  },
  async send(attachment: PendingAttachment) {
    const id = fileIdMap[attachment.id] || attachment.id;
    delete fileIdMap[attachment.id];
    return {
      ...attachment,
      id,
      status: { type: "complete" },
      content: [
        {
          type: "file",
          mimeType: attachment.contentType,
          filename: attachment.name,
          data: "",
        },
      ],
    };
  },
};
```